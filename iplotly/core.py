"""
"""

import collections

import plotly.graph_objs as go

from . import utils
from . import graph_objs as igo


# ------------------------------

class Plot(object):
    """Main class for creating, showing, and exporting Plotly plots
    interactively.
    """

    def __init__(self, width=1000, height=500, **layout_props):
        self._fig = go.Figure(
            data=[],
            layout=go.Layout(
                width=width,
                height=height,
                **layout_props))
        self._traces = collections.OrderedDict()
        self.defs = utils.load_defaults()

    def _trace_key(self, typ, name):
        return utils.unique_key(typ, name, self._traces.keys())

    def _add_trace(self, cls, x, y, defs, props):
        """Add a Plotly object to the trace stack.  The object is generated by
        the given function with the given x-y args and properties.
        """
        key = self._trace_key(cls.__name__.lower(), props.get("name"))
        self._traces[key] = cls(x, y, defs, **props)

    def __repr__(self):
        return repr(self._fig)

    @property
    def fig(self):
        """Return the Plotly figure object.
        """
        self._fig.data = [tr.graph_obj for k, tr in self._traces.iteritems()]
        return self._fig

    @property
    def traces(self):
        """Return the dict that holds the trace objects:
        """
        return self._traces

    @property
    def trace_keys(self):
        return self._traces.keys()

    @property
    def layout(self):
        return self.fig.layout

    def update_layout(self, **props):
        """Update a Plotly layout property with the given value.

        ToDo
        ----
        * Make this work when the value is a list (e.g., shapes, annotations)
        """
        for k, v in props.iteritems():
            if isinstance(v, dict):
                self._fig['layout'][k].update(v)
            elif "__" in k:
                splt = k.split("__")
                self._fig['layout'][splt[0]].update({splt[1]: v})
            else:
                self._fig['layout'][k] = v
        return self

    def update_trace(self, key, **props):
        """Update the trace corresponding to the given key.
        """
        obj = self._traces[key]
        if 'gap' in props and obj.graph_obj.type == 'bar':
            self.update_layout(bargap=props.pop('gap'))
        for k, v in props.iteritems():
            setattr(obj, k, v)
        return self

    def remove_trace(self, key):
        """Remove a trace with the given key.
        """
        self._traces.pop(key)
        return self

    def pop_trace(self):
        """Pop the last-added trace.
        """
        self._traces.popitem()
        return self

    def clear_traces(self):
        """Remove all traces.
        """
        self._traces = collections.OrderedDict()
        return self

    def add_scatter(self, x, y, **props):
        """Add a scatter trace to the figure.
        """
        # self._add_trace(_scatter, x, y, props)
        self._add_trace(igo.Scatter, x, y, self.defs, props)
        return self

    def add_line(self, x, y, **props):
        """Add a line trace to the figure.
        """
        # self._add_trace(_line, x, y, props)
        self._add_trace(igo.Line, x, y, self.defs, props)
        return self

    def add_bar(self, x, y, **props):
        """Add a bar trace to the figure.
        """
        self.update_layout(bargap=props.get("gap", self.defs['bar']['gap']))
        self._add_trace(igo.Bar, x, y, self.defs, props)
        return self

    def add_point(self, x, y, **props):
        """Add a single point as a single-point scatter trace.
        """
        self.add_scatter([x], [y], **props)
        return self

    def add_vline(self, x, yrng=None, **props):
        """Add a vertical line at the given position that spans the plot
        window.
        """
        xref = props.get('xref', 'x')
        yref = props.get('yref', 'paper')
        y0, y1 = (0, 1)
        if yrng is not None:
            yref = 'y'
            y0, y1 = yrng
        self._fig.layout.shapes.append(dict(
            type='line', layer=props.get('layer', 'above'),
            xref=xref, yref=yref,
            x0=x, x1=x,
            y0=y0, y1=y1,
            line=dict(
                width=props.get('width', self.defs['line']['width']),
                dash=props.get('dash', self.defs['line']['dash']),
                color=props.get('color', self.defs['global']['color']))))
        return self

    def add_annotation(self, x, y, text, **props):
        """Add a text annotation at the given coordinates.

        Notes
        -----
        * This is a first pass implementation and doesn't offer the same
          easy mutability of the scatter, line, and bar plot elements.
        """
        size = props.get('size', 12)
        color = props.get('color', 'black')
        self._fig.layout.annotations.append(dict(
            x=x, y=y, text=text,
            xref=props.get('xref', 'x'), yref=props.get('yref', 'y'),
            showarrow=props.get('showarrow', False),
            xanchor=props.get('xanchor', 'center'),
            yanchor=props.get('yanchor', 'bottom'),
            font=dict(size=size, color=color)))
        return self

    def show(self):
        """Show the rendered Plotly plot in a Jupyter notebook.
        """
        utils.fig_show(self.fig)
        return self

    def to_json(self):
        """Return the JSON serialization of the Plotly Figure object.
        """
        return utils.fig_to_json(self.fig)

    def to_html(self, path):
        """Save the Plotly HTML to the given path.
        """
        return utils.fig_to_html(self.fig, path)
